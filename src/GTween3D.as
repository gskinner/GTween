/*GTween3D for GTween by Grant Skinner, gskinner.com/blog/This example demonstrates four concepts:1) Using GTween on 3D properties in Flash player 10.2) Using the data property to store transition related data.3) Reusing tweens.4) Interruptable tweens.5) Using the blur plugin.The whole demo with graphics is only about 5kb.Test movie, and click an image to bring it to the front, click anywhere to send it back.Note that you can click before tweens finish, and the tweens will adapt as needed- though you may see occasional issues with the very simple depth sorting in this demo.*/package  {		import com.gskinner.motion.GTween;	import com.gskinner.motion.easing.*;	import com.gskinner.motion.plugins.BlurPlugin;		import flash.events.Event;	import flash.events.MouseEvent;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.filters.BlurFilter;		public class GTween3D extends MovieClip {			// Constants:			// Public Properties:			// Protected Properties:			protected var canvas:Sprite = new Sprite();		protected var images:Array = [];		protected var tweens:Array = [];		protected var rows:int = 5;		protected var cols:int = 7;		protected var currentImage:Image;			// Initialization:		public function GTween3D() {			BlurPlugin.install();			for (var row:int=0; row<rows; row++) {				for (var col:int=0; col<cols; col++) {										// lay out all the images:					var image:Image = new Image();					image.x = col*150-cols*150/2+image.width/2;					image.y = row*150-rows*150/2+image.height/2;					image.z = 500;					image.filters = [new BlurFilter(16,16,2)];					images.push(image);					canvas.addChild(image);					if (col == 4 && row == 3) { image.gotoAndStop(2); }										// set up the initial tweens with null for the properties parameter, because we don't need to tween anything initially.					// we're just setting it up for later use.					var tween:GTween = new GTween(image,1,null,{ease:Sine.easeInOut});					// we'll use the data property of the tween to store transition related properties, like the original x & y of the image.					tween.data = {x:image.x,y:image.y};					tweens.push(tween);				}			}			canvas.x = 275;			canvas.y = 200;			addChild(canvas);						stage.addEventListener(MouseEvent.CLICK,handleClick);			stage.addEventListener(Event.ENTER_FRAME,handleTick);		}			// Public getter / setters:			// Public Methods:			// Protected Methods:		protected function handleClick(evt:MouseEvent):void {			var tween:GTween;			var i:int;			var targetImage:Image = evt.target as Image;			if (currentImage) {				// zoom in all images:				for (i=0; i<tweens.length; i++) {					tween = tweens[i] as GTween;					tween.proxy.z = 500;					tween.proxy.alpha = 1;				}								// tween the current image back into position:				tween = tweens[images.indexOf(currentImage)] as GTween;				tween.proxy.rotationX=0;				tween.proxy.x=tween.data.x;				tween.proxy.y=tween.data.y;				tween.proxy.blur = 16;				if (targetImage == currentImage) { targetImage = null; }				currentImage = null;			}			if (targetImage) {				// zoom out all images:				for (i=0; i<tweens.length; i++) {					tween = tweens[i] as GTween;					tween.proxy.z=800;					tween.proxy.alpha=0.25;				}								currentImage = targetImage;								// zoom in the current image:				tween = tweens[images.indexOf(currentImage)] as GTween;				tween.proxy.z=0;				tween.proxy.alpha=1;				// flip it:				tween.proxy.rotationX=360;				// and pull it towards the center:				tween.proxy.x=tween.data.x*0.4;				tween.proxy.y=tween.data.y*0.4;				tween.proxy.blur = 0;				// depth sort it to the front:				currentImage.parent.addChild(currentImage);			}		}				// sometimes using a tweening engine doesn't make sense, such as with reactive logic.		protected function handleTick(evt:Event):void {			canvas.rotationY += ((Math.max(0,Math.min(550,mouseX))-275)*-0.04 - canvas.rotationY)*0.15;			canvas.rotationX += ((Math.max(0,Math.min(400,mouseY))-200)*0.04 - canvas.rotationX)*0.15;		}	}	}